<!DOCTYPE html><!--OVt0H6to9QSgb_YS8ef_u--><html lang="ja"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/5e22d3fe14facb50.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-a736bdd7de20ec56.js"/><script src="/_next/static/chunks/c2bb8663-25b9ddcb298b2a19.js" async=""></script><script src="/_next/static/chunks/933-bc707027486726a4.js" async=""></script><script src="/_next/static/chunks/main-app-72d284f8ed369795.js" async=""></script><script src="/_next/static/chunks/119-2ee48d1f375d3fd9.js" async=""></script><script src="/_next/static/chunks/app/page-ee49d1414c09869d.js" async=""></script><title>MyDocs</title><meta name="description" content="A simple SSG blog built with Next.js"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body style="background-color:ghostwhite;margin:0;min-height:100vh"><div hidden=""><!--$--><!--/$--></div><header style="padding:1rem 0;margin-bottom:0.25rem"><div style="max-width:1000px;margin:0 auto;padding:0 2rem"><a style="font-size:1.5rem;font-weight:bold;text-decoration:none;color:#333" href="/">MyDocs</a></div></header><article style="max-width:1000px;margin:0 auto;padding:0 2rem 2rem"><h1>Golangのhttp/netについて調べた</h1><div><h2>サーバ</h2>
<p>何もしないサーバを起動。</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"net/http"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	http.ListenAndServe(<span class="hljs-string">""</span>, <span class="hljs-literal">nil</span>)
}
</code></pre>
<p><code>ListenAndServe</code> はネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は <code>DefaultServerMux</code> が使われる。</p>
<p>Server の構造体はこんな感じ。</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> Server <span class="hljs-keyword">struct</span> {
	Addr <span class="hljs-type">string</span>
	Handler Handler
	TLSConfig *tls.Config
	ReadTimeout time.Duration
	ReadHeaderTimeout time.Duration
	WriteTimeout time.Duration
	IdleTimeout time.Duration
	MaxHeaderBytes <span class="hljs-type">int</span>
	TLSNextProto <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Server, *tls.Conn, Handler)</span></span>
	ConnState <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(net.Conn, ConnState)</span></span>
	ErrorLog *log.Logger
	BaseContext <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(net.Listener)</span></span> context.Context
	ConnContext <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, c net.Conn)</span></span> context.Context
	inShutdown atomicBool
	disableKeepAlives <span class="hljs-type">int32</span>
	nextProtoOnce     sync.Once
	nextProtoErr      <span class="hljs-type">error</span>
	mu         sync.Mutex
	listeners  <span class="hljs-keyword">map</span>[*net.Listener]<span class="hljs-keyword">struct</span>{}
	activeConn <span class="hljs-keyword">map</span>[*conn]<span class="hljs-keyword">struct</span>{}
	doneChan   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{}
	onShutdown []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>
}
</code></pre>
<p>設定を変更する場合は Server の構造体に値を指定する。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	server := http.Server{
		Addr:    <span class="hljs-string">"0.0.0.0:8080"</span>,
		Handler: <span class="hljs-literal">nil</span>,
	}
	server.ListenAndServe()
</code></pre>
<h3>ハンドラとハンドラ関数</h3>
<p>ハンドラがない場合すべてのリクエストで 404 を返す。</p>
<p>ハンドラとは、 <code>ServerHTTP メソッド</code> を持ったインターフェースのことを指す。
このメソッドは、 <code>インターフェース HTTPResponseWriter</code> と <code>構造体 Request のポインタ</code> の 2 つの引数を取る。
つまり、 <code>ServerHTTP(http.ResponseWriter, *http.Request)</code> をもつインターフェースがハンドラになる。</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> HelloHandler <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloHandler)</span></span> ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(writer, <span class="hljs-string">"hello"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	helloHandler := <span class="hljs-built_in">new</span>(HelloHandler)
	server := http.Server{
		Addr:    <span class="hljs-string">"0.0.0.0:8080"</span>,
		Handler: helloHandler,
	}
	server.ListenAndServe()
}
</code></pre>
<p>この状態だと、すべてのアクセスが 1 つのハンドラに行く。</p>
<p>実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない ( デフォルトで DefaultServerMux を使う ) 。</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> HelloHandler <span class="hljs-keyword">struct</span>{}
<span class="hljs-keyword">type</span> WorldHandler <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloHandler)</span></span> ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(writer, <span class="hljs-string">"hello"</span>)
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *WorldHandler)</span></span> ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(writer, <span class="hljs-string">"world"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	helloHandler := <span class="hljs-built_in">new</span>(HelloHandler)
	worldHandler := <span class="hljs-built_in">new</span>(WorldHandler)
	server := http.Server{
		Addr: <span class="hljs-string">"0.0.0.0:8080"</span>,
	}
	http.Handle(<span class="hljs-string">"/hello"</span>, helloHandler)
	http.Handle(<span class="hljs-string">"/world"</span>, worldHandler)
	server.ListenAndServe()
}
</code></pre>
<p><code>http.Handle</code> は実際には DefaultServeMux の Handle メソッドを呼び出している。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>, handler Handler)</span></span> { DefaultServeMux.Handle(pattern, handler) }
</code></pre>
<p>ハンドラとは、 <code>ServerHTTP(http.ResponseWriter, *http.Request)</code> をもつインターフェースのこと。
ハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"net/http"</span>
)

<span class="hljs-keyword">type</span> HelloHandler <span class="hljs-keyword">struct</span>{}
<span class="hljs-keyword">type</span> WorldHandler <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *HelloHandler)</span></span> ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(writer, <span class="hljs-string">"hello"</span>)
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *WorldHandler)</span></span> ServeHTTP(writer http.ResponseWriter, request *http.Request) {
	fmt.Fprintf(writer, <span class="hljs-string">"world"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> {
	fmt.Fprintf(writer, <span class="hljs-string">"hello"</span>)
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">world</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> {
	fmt.Fprintf(writer, <span class="hljs-string">"world"</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	helloHandler := <span class="hljs-built_in">new</span>(HelloHandler)
	worldHandler := <span class="hljs-built_in">new</span>(WorldHandler)
	server := http.Server{
		Addr: <span class="hljs-string">"0.0.0.0:8080"</span>,
	}
	http.Handle(<span class="hljs-string">"/hello"</span>, helloHandler)
	http.Handle(<span class="hljs-string">"/world"</span>, worldHandler)
	http.HandleFunc(<span class="hljs-string">"/hello2"</span>, hello)
	http.HandleFunc(<span class="hljs-string">"/world2"</span>, world)
	server.ListenAndServe()
}
</code></pre>
<h3>何が違うのか</h3>
<p>やってることは <code>DefaultServeMux.Handle(pattern, handler)</code> なので同じ。
既存のインターフェースがある場合は、 <code>ServeHTTP</code> メソッドを追加するだけでハンドラになるからそういった場合は、 <code>http.Handle</code> のほうが手軽。</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handle</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>, handler Handler)</span></span> { DefaultServeMux.Handle(pattern, handler) }

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HandleFunc</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>, handler <span class="hljs-keyword">func</span>(ResponseWriter, *Request)</span></span>) {
	DefaultServeMux.HandleFunc(pattern, handler)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mux *ServeMux)</span></span> HandleFunc(pattern <span class="hljs-type">string</span>, handler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ResponseWriter, *Request)</span></span>) {
	<span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> {
		<span class="hljs-built_in">panic</span>(<span class="hljs-string">"http: nil handler"</span>)
	}
	mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>
<h2>サードパーティー製のマルチプレクサ</h2>
<p>標準でも特に辛くない。 <code>request.Method</code> でメソッドも取得できるのでかなり使い勝手もいい。</p>
<pre><code class="hljs language-go">mux.HandleFunc(<span class="hljs-string">"/users/create"</span>, createUsers)
mux.HandleFunc(<span class="hljs-string">"/users/read/"</span>, readUsers)
mux.HandleFunc(<span class="hljs-string">"/users/update/"</span>, updateUsers)
mux.HandleFunc(<span class="hljs-string">"/users/delete/"</span>, deleteUsers)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readerUsers</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> {
	sub := strings.TrimPrefix(request.URL.Path, <span class="hljs-string">"/users/read/"</span>)
	userId, err := strconv.Atoi(sub) <span class="hljs-comment">// これで /users/read/:id の id を取得できる</span>
}
</code></pre>
<p>下記のような、 <code>/users/:user_id/tasks/:task_id</code> みたいに解析を結構頑張らないといけない場合は結構辛い。</p>
<pre><code class="hljs language-go">mux.HandleFunc(<span class="hljs-string">"/users/2/tasks/create"</span>, createUsers)
mux.HandleFunc(<span class="hljs-string">"/users/2/tasks/read/"</span>, readUsers)
mux.HandleFunc(<span class="hljs-string">"/users/2/tasks/update/"</span>, updateUsers)
mux.HandleFunc(<span class="hljs-string">"/users/2/tasks/delete/"</span>, deleteUsers)
</code></pre>
<p>この辺が良さそう。</p>
<ul>
<li><a href="https://github.com/gorilla/mux">https://github.com/gorilla/mux</a></li>
<li><a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></li>
</ul></div></article><!--$--><!--/$--><script src="/_next/static/chunks/webpack-a736bdd7de20ec56.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[9119,[\"119\",\"static/chunks/119-2ee48d1f375d3fd9.js\",\"974\",\"static/chunks/app/page-ee49d1414c09869d.js\"],\"\"]\n3:I[730,[],\"\"]\n4:I[2392,[],\"\"]\n6:I[3811,[],\"OutletBoundary\"]\n8:I[4338,[],\"AsyncMetadataOutlet\"]\na:I[3811,[],\"ViewportBoundary\"]\nc:I[3811,[],\"MetadataBoundary\"]\nd:\"$Sreact.suspense\"\nf:I[9426,[],\"\"]\n:HL[\"/_next/static/css/5e22d3fe14facb50.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"OVt0H6to9QSgb-YS8ef-u\",\"p\":\"\",\"c\":[\"\",\"docs\",\"20210723021243\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"20210723021243\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/5e22d3fe14facb50.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ja\",\"children\":[\"$\",\"body\",null,{\"style\":{\"backgroundColor\":\"ghostwhite\",\"margin\":0,\"minHeight\":\"100vh\"},\"children\":[[\"$\",\"header\",null,{\"style\":{\"padding\":\"1rem 0\",\"marginBottom\":\"0.25rem\"},\"children\":[\"$\",\"div\",null,{\"style\":{\"maxWidth\":\"1000px\",\"margin\":\"0 auto\",\"padding\":\"0 2rem\"},\"children\":[\"$\",\"$L2\",null,{\"href\":\"/\",\"style\":{\"fontSize\":\"1.5rem\",\"fontWeight\":\"bold\",\"textDecoration\":\"none\",\"color\":\"#333\"},\"children\":\"MyDocs\"}]}]}],[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]}]]}],{\"children\":[\"docs\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"slug\",\"20210723021243\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L5\",null,[\"$\",\"$L6\",null,{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"promise\":\"$@9\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[[\"$\",\"$La\",null,{\"children\":\"$Lb\"}],null],[\"$\",\"$Lc\",null,{\"children\":[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$d\",null,{\"fallback\":null,\"children\":\"$Le\"}]}]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$f\",[]],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"10:T2e6e,"])</script><script>self.__next_f.push([1,"\u003ch2\u003eサーバ\u003c/h2\u003e\n\u003cp\u003e何もしないサーバを起動。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"net/http\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\thttp.ListenAndServe(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eListenAndServe\u003c/code\u003e はネットワークアドレスとハンドラを引数で受け取る。ハンドラが nil の場合は \u003ccode\u003eDefaultServerMux\u003c/code\u003e が使われる。\u003c/p\u003e\n\u003cp\u003eServer の構造体はこんな感じ。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e Server \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e {\n\tAddr \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e\n\tHandler Handler\n\tTLSConfig *tls.Config\n\tReadTimeout time.Duration\n\tReadHeaderTimeout time.Duration\n\tWriteTimeout time.Duration\n\tIdleTimeout time.Duration\n\tMaxHeaderBytes \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e\n\tTLSNextProto \u003cspan class=\"hljs-keyword\"\u003emap\u003c/span\u003e[\u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e]\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(*Server, *tls.Conn, Handler)\u003c/span\u003e\u003c/span\u003e\n\tConnState \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(net.Conn, ConnState)\u003c/span\u003e\u003c/span\u003e\n\tErrorLog *log.Logger\n\tBaseContext \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(net.Listener)\u003c/span\u003e\u003c/span\u003e context.Context\n\tConnContext \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(ctx context.Context, c net.Conn)\u003c/span\u003e\u003c/span\u003e context.Context\n\tinShutdown atomicBool\n\tdisableKeepAlives \u003cspan class=\"hljs-type\"\u003eint32\u003c/span\u003e\n\tnextProtoOnce     sync.Once\n\tnextProtoErr      \u003cspan class=\"hljs-type\"\u003eerror\u003c/span\u003e\n\tmu         sync.Mutex\n\tlisteners  \u003cspan class=\"hljs-keyword\"\u003emap\u003c/span\u003e[*net.Listener]\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\tactiveConn \u003cspan class=\"hljs-keyword\"\u003emap\u003c/span\u003e[*conn]\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\tdoneChan   \u003cspan class=\"hljs-keyword\"\u003echan\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\tonShutdown []\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e設定を変更する場合は Server の構造体に値を指定する。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\tserver := http.Server{\n\t\tAddr:    \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0:8080\"\u003c/span\u003e,\n\t\tHandler: \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e,\n\t}\n\tserver.ListenAndServe()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eハンドラとハンドラ関数\u003c/h3\u003e\n\u003cp\u003eハンドラがない場合すべてのリクエストで 404 を返す。\u003c/p\u003e\n\u003cp\u003eハンドラとは、 \u003ccode\u003eServerHTTP メソッド\u003c/code\u003e を持ったインターフェースのことを指す。\nこのメソッドは、 \u003ccode\u003eインターフェース HTTPResponseWriter\u003c/code\u003e と \u003ccode\u003e構造体 Request のポインタ\u003c/code\u003e の 2 つの引数を取る。\nつまり、 \u003ccode\u003eServerHTTP(http.ResponseWriter, *http.Request)\u003c/code\u003e をもつインターフェースがハンドラになる。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e HelloHandler \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(h *HelloHandler)\u003c/span\u003e\u003c/span\u003e ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\thelloHandler := \u003cspan class=\"hljs-built_in\"\u003enew\u003c/span\u003e(HelloHandler)\n\tserver := http.Server{\n\t\tAddr:    \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0:8080\"\u003c/span\u003e,\n\t\tHandler: helloHandler,\n\t}\n\tserver.ListenAndServe()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこの状態だと、すべてのアクセスが 1 つのハンドラに行く。\u003c/p\u003e\n\u003cp\u003e実際は URL ごとに異なるハンドラで処理する必要があるため Handler フィールドに値を指定しない ( デフォルトで DefaultServerMux を使う ) 。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e HelloHandler \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e WorldHandler \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(h *HelloHandler)\u003c/span\u003e\u003c/span\u003e ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(w *WorldHandler)\u003c/span\u003e\u003c/span\u003e ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"world\"\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\thelloHandler := \u003cspan class=\"hljs-built_in\"\u003enew\u003c/span\u003e(HelloHandler)\n\tworldHandler := \u003cspan class=\"hljs-built_in\"\u003enew\u003c/span\u003e(WorldHandler)\n\tserver := http.Server{\n\t\tAddr: \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0:8080\"\u003c/span\u003e,\n\t}\n\thttp.Handle(\u003cspan class=\"hljs-string\"\u003e\"/hello\"\u003c/span\u003e, helloHandler)\n\thttp.Handle(\u003cspan class=\"hljs-string\"\u003e\"/world\"\u003c/span\u003e, worldHandler)\n\tserver.ListenAndServe()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ehttp.Handle\u003c/code\u003e は実際には DefaultServeMux の Handle メソッドを呼び出している。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHandle\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(pattern \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e, handler Handler)\u003c/span\u003e\u003c/span\u003e { DefaultServeMux.Handle(pattern, handler) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eハンドラとは、 \u003ccode\u003eServerHTTP(http.ResponseWriter, *http.Request)\u003c/code\u003e をもつインターフェースのこと。\nハンドラ関数とは、ハンドラのように振る舞う関数。リクエストのポインタを受け取ることができる。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e (\n\t\u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n\t\u003cspan class=\"hljs-string\"\u003e\"net/http\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e HelloHandler \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\u003cspan class=\"hljs-keyword\"\u003etype\u003c/span\u003e WorldHandler \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e{}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(h *HelloHandler)\u003c/span\u003e\u003c/span\u003e ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(w *WorldHandler)\u003c/span\u003e\u003c/span\u003e ServeHTTP(writer http.ResponseWriter, request *http.Request) {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"world\"\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ehello\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"hello\"\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eworld\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\n\tfmt.Fprintf(writer, \u003cspan class=\"hljs-string\"\u003e\"world\"\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n\thelloHandler := \u003cspan class=\"hljs-built_in\"\u003enew\u003c/span\u003e(HelloHandler)\n\tworldHandler := \u003cspan class=\"hljs-built_in\"\u003enew\u003c/span\u003e(WorldHandler)\n\tserver := http.Server{\n\t\tAddr: \u003cspan class=\"hljs-string\"\u003e\"0.0.0.0:8080\"\u003c/span\u003e,\n\t}\n\thttp.Handle(\u003cspan class=\"hljs-string\"\u003e\"/hello\"\u003c/span\u003e, helloHandler)\n\thttp.Handle(\u003cspan class=\"hljs-string\"\u003e\"/world\"\u003c/span\u003e, worldHandler)\n\thttp.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/hello2\"\u003c/span\u003e, hello)\n\thttp.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/world2\"\u003c/span\u003e, world)\n\tserver.ListenAndServe()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e何が違うのか\u003c/h3\u003e\n\u003cp\u003eやってることは \u003ccode\u003eDefaultServeMux.Handle(pattern, handler)\u003c/code\u003e なので同じ。\n既存のインターフェースがある場合は、 \u003ccode\u003eServeHTTP\u003c/code\u003e メソッドを追加するだけでハンドラになるからそういった場合は、 \u003ccode\u003ehttp.Handle\u003c/code\u003e のほうが手軽。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHandle\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(pattern \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e, handler Handler)\u003c/span\u003e\u003c/span\u003e { DefaultServeMux.Handle(pattern, handler) }\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eHandleFunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(pattern \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e, handler \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e(ResponseWriter, *Request)\u003c/span\u003e\u003c/span\u003e) {\n\tDefaultServeMux.HandleFunc(pattern, handler)\n}\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003e(mux *ServeMux)\u003c/span\u003e\u003c/span\u003e HandleFunc(pattern \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e, handler \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(ResponseWriter, *Request)\u003c/span\u003e\u003c/span\u003e) {\n\t\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e handler == \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e {\n\t\t\u003cspan class=\"hljs-built_in\"\u003epanic\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"http: nil handler\"\u003c/span\u003e)\n\t}\n\tmux.Handle(pattern, HandlerFunc(handler))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eサードパーティー製のマルチプレクサ\u003c/h2\u003e\n\u003cp\u003e標準でも特に辛くない。 \u003ccode\u003erequest.Method\u003c/code\u003e でメソッドも取得できるのでかなり使い勝手もいい。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003emux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/create\"\u003c/span\u003e, createUsers)\nmux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/read/\"\u003c/span\u003e, readUsers)\nmux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/update/\"\u003c/span\u003e, updateUsers)\nmux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/delete/\"\u003c/span\u003e, deleteUsers)\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ereaderUsers\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(writer http.ResponseWriter, request *http.Request)\u003c/span\u003e\u003c/span\u003e {\n\tsub := strings.TrimPrefix(request.URL.Path, \u003cspan class=\"hljs-string\"\u003e\"/users/read/\"\u003c/span\u003e)\n\tuserId, err := strconv.Atoi(sub) \u003cspan class=\"hljs-comment\"\u003e// これで /users/read/:id の id を取得できる\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下記のような、 \u003ccode\u003e/users/:user_id/tasks/:task_id\u003c/code\u003e みたいに解析を結構頑張らないといけない場合は結構辛い。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003emux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/2/tasks/create\"\u003c/span\u003e, createUsers)\nmux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/2/tasks/read/\"\u003c/span\u003e, readUsers)\nmux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/2/tasks/update/\"\u003c/span\u003e, updateUsers)\nmux.HandleFunc(\u003cspan class=\"hljs-string\"\u003e\"/users/2/tasks/delete/\"\u003c/span\u003e, deleteUsers)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこの辺が良さそう。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/gorilla/mux\"\u003ehttps://github.com/gorilla/mux\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/julienschmidt/httprouter\"\u003ehttps://github.com/julienschmidt/httprouter\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"5:[\"$\",\"article\",null,{\"style\":{\"maxWidth\":\"1000px\",\"margin\":\"0 auto\",\"padding\":\"0 2rem 2rem\"},\"children\":[[\"$\",\"h1\",null,{\"children\":\"Golangのhttp/netについて調べた\"}],[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$10\"}}]]}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n7:null\n"])</script><script>self.__next_f.push([1,"9:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"MyDocs\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"A simple SSG blog built with Next.js\"}]],\"error\":null,\"digest\":\"$undefined\"}\n"])</script><script>self.__next_f.push([1,"e:\"$9:metadata\"\n"])</script></body></html>